//HGE 中文显示新方案
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//Author  - 微妙的平衡(BOGY)
//Mail    - bogy.cn@gmail.com
//Home    - http://bogy.cn
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
unit GfxFont;

interface
uses
  Windows, HGE, HGESprite;

const
  Font_Count = High(Word);
type
  tagEngineFontGlyph = record
    t: ITexture;
    w: Single;
    h: Single;
    x: Single;
    y: Single;
    c: Single;
  end;
  TENGINEFONTGLYPH = tagEngineFontGlyph;

  TGfxFont = class
  public
    constructor Create(const FontName: PWideChar; FaceSize: Integer; bBold: Boolean = False;
      bItalic: Boolean = False; bAntialias: Boolean = True);
    destructor Destroy(); override;
  public
    // 渲染文本
    procedure Print(X: Single; Y: Single; Text: PWideChar);
    // 设置与获取颜色
    procedure SetColor(Color: Cardinal; i: Integer = -1);
    function GetColor(i: Integer = 0): Cardinal;
    // 获取文本宽高
    function GetTextSize(Text: PWideChar): TSize;
    // 根据坐标获取字符
    function GetCharacterFromPos(Text: PWideChar; Pixel_X, Pixel_Y: Single): WideChar;
    // 设置字间距
    procedure SetKerningWidth(Kerning: Single);
    procedure SetKerningHeight(Kerning: Single);
    // 获取字间距
    function GetKerningWidth(): Single;
    function GetKerningHeight(): Single;
    // 字体大小
    function GetFontSize(): Single;
  private
    m_Glyphs: array [0..Font_Count-1] of TENGINEFONTGLYPH;
    m_nAntialias: Cardinal;//反锯齿
    m_nAscent: Integer;//基线
    //m_dwFontColor: Cardinal;
    m_nFontSize: Single;
    m_nKerningWidth: Single;
    m_nKerningHeight: Single;
    m_pHGE: IHGE;
    m_pSprite: IHGESprite;
    // GDI设备
    m_hMemDC: HDC;
    m_hFont: HFONT;
    function GetGlyphByCharacter(C: WideChar): Cardinal;
    function GetWidthFromCharacter(C: WideChar; Original: Boolean = False): Single;
    procedure CacheCharacter(Idx: Cardinal; C: WideChar);
  end;

implementation

{ TGfxFont }

const
  g_byAlphaLever: array [0..65 - 1] of Byte =
  (
    0,  4,  8,  12, 16, 20, 24, 28, 32, 36, 40, 44, 48,
      52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100,
    104,108,112,116,120,124,128,132,136,140,144,148,152,
    156,160,164,168,172,176,180,184,188,192,196,200,204,
    208,212,216,220,224,228,232,236,240,244,248,252,255
  );

const
  WideNull  = WideChar(#0);
  WideCR    = WideChar(#13);
  WideLF    = WideChar(#10);
  WideCRLF  : WideString = #13#10;
 
type
  TByteAry = array [0..0] of Byte;
  PByteAry = ^TByteAry;
procedure TGfxFont.CacheCharacter(Idx: Cardinal; C: WideChar);
var
  nChar: Cardinal;
  mat: MAT2;
  gm: GLYPHMETRICS;
  nLen: Cardinal;
  hTex: ITexture;
  lpBuf: PByteAry;
  lpSrc: PByteAry;
  lpDst: PLongWord;
  nSrcPitch, nDstPitch: Cardinal;
  x, y, k, i: Cardinal;
begin
  if (Idx < Font_Count) and (m_Glyphs[Idx].t = nil) then
  begin
    nChar := Cardinal(C);
    mat.eM11.fract := 0; mat.eM11.value := 1;
    mat.eM12.fract := 0; mat.eM12.value := 0;
    mat.eM21.fract := 0; mat.eM21.value := 0;
    mat.eM22.fract := 0; mat.eM22.value := 1;
    nLen := GetGlyphOutlineW(m_hMemDC, nChar, m_nAntialias, gm, 0, nil, mat);
    hTex := m_pHGE.Texture_Create(gm.gmBlackBoxX, gm.gmBlackBoxY);
    if hTex = nil then Exit;

    if nLen > 0 then
    begin
      GetMem(lpBuf, nLen);
      if nLen = GetGlyphOutlineW(m_hMemDC, nChar, m_nAntialias, gm, nLen, lpBuf,
        mat) then
      begin
        lpSrc := lpBuf;
        lpDst := m_pHGE.Texture_Lock(hTex, False);
        if GGO_BITMAP = m_nAntialias then
        begin
          if gm.gmBlackBoxX mod 32 = 0 then
            nSrcPitch := (gm.gmBlackBoxX div 32)*4
          else
            nSrcPitch := ((gm.gmBlackBoxX div 32) + 1)*4;
          nDstPitch := m_pHGE.Texture_GetWidth(hTex);

          for y := 0 to gm.gmBlackBoxY - 1 do
          begin
            x := 0;
            while x < gm.gmBlackBoxX do
            begin
              for k := 0 to 7 do
              begin
                i := 8*x + k;
                if i >= gm.gmBlackBoxX then
                begin
                  Inc(x, 7);
                  Break;
                end;
                if (lpSrc[x] shr (7 - k)) and 1 = 0 then
                  PCardinal(Cardinal(lpDst) + i * SizeOf(Integer))^ := 0
                else
                  PCardinal(Cardinal(lpDst) + i * SizeOf(Integer))^ := $FFFFFFFF;
              end;
              Inc(x);
            end;
            Inc(lpSrc, nSrcPitch);
            Inc(lpDst, nDstPitch); 
          end; 
        end
        else
        begin
          if gm.gmBlackBoxX mod 4 = 0 then
            nSrcPitch := (gm.gmBlackBoxX div 4)*4
          else
            nSrcPitch := (gm.gmBlackBoxX div 4 + 1)*4;
          nDstPitch := m_pHGE.Texture_GetWidth(hTex);
          for y := 0 to gm.gmBlackBoxY - 1 do
          begin
            for x := 0 to gm.gmBlackBoxX - 1 do
              PCardinal(Cardinal(lpDst) + x * SizeOf(Integer))^ :=
                ARGB(g_byAlphaLever[lpSrc[x]], $FF, $FF, $FF);
            Inc(lpSrc, nSrcPitch);
            Inc(lpDst, nDstPitch);
          end; 
        end;
        m_pHGE.Texture_Unlock(hTex);   
      end;
      FreeMem(lpBuf);
    end
    else
    begin
      // 非正常显示字符
    end;
    m_Glyphs[Idx].t := hTex;
    m_Glyphs[Idx].w := gm.gmBlackBoxX;
    m_Glyphs[Idx].h := gm.gmBlackBoxY;
    m_Glyphs[Idx].x := -gm.gmptGlyphOrigin.X;
    m_Glyphs[Idx].y := gm.gmptGlyphOrigin.Y - m_nAscent;
    m_Glyphs[Idx].c := gm.gmCellIncX;
  end;
end;

constructor TGfxFont.Create(const FontName: PWideChar; FaceSize: Integer;
  bBold, bItalic, bAntialias: Boolean);
var
  h_DC: HDC;
  Bold: Integer;
  tm: TEXTMETRICW;
begin
  m_pHGE := HGECreate(HGE_VERSION);
  // 创建GDI相关设备
  h_DC := GetDC(m_pHGE.System_GetState(HGE_HWND));
  m_hMemDC := CreateCompatibleDC(h_DC);
  if m_hMemDC = 0 then Exit;

  ReleaseDC(m_pHGE.System_GetState(HGE_HWND), h_DC);
  SetMapMode(m_hMemDC, MM_TEXT);
  SetTextColor(m_hMemDC, RGB($FF, $FF, $FF));
  SetBkColor(m_hMemDC, RGB(0, 0, 0));

  if bBold then
    Bold := FW_BOLD
  else
    Bold := FW_NORMAL;
  m_hFont := CreateFontW(
    -FaceSize,
    0,
    0,
    0,
    Bold,
    Integer(bItalic),
    Cardinal(False),
    Cardinal(False),
    DEFAULT_CHARSET,
    OUT_DEFAULT_PRECIS,
    CLIP_DEFAULT_PRECIS,
    DEFAULT_QUALITY,
    FF_DONTCARE or DEFAULT_PITCH,
    FontName);
  if m_hFont = 0 then Exit;

  SelectObject(m_hMemDC, m_hFont);
  FillChar(m_Glyphs, SizeOf(TENGINEFONTGLYPH)*Font_Count, 0);
  if bAntialias then
    m_nAntialias := GGO_GRAY8_BITMAP
  else
    m_nAntialias := GGO_BITMAP;
  GetTextMetricsW(m_hMemDC, tm);
  m_nAscent := tm.tmAscent;
  m_nFontSize := FaceSize;
  m_nKerningWidth := 0;
  m_nKerningHeight := 0;
  m_pSprite := THGESprite.Create(nil, 0, 0, 0, 0);
  m_pSprite.SetColor(ARGB($FF, $FF, $FF, $FF));
end;

destructor TGfxFont.Destroy;
var
  nIdx: Integer;
begin
  for nIdx := 0 to Font_Count - 1 do
    if m_Glyphs[nIdx].t <> nil then
      m_Glyphs[nIdx].t := nil;

  if m_hFont <> 0 then
    DeleteObject(m_hFont);
  if m_hMemDC <> 0 then
    DeleteDC(m_hMemDC);
  if m_pSprite <> nil then
    m_pSprite := nil;
  if m_pHGE <> nil then
    m_pHGE := nil;
  inherited;
end;

function TGfxFont.GetCharacterFromPos(Text: PWideChar; Pixel_X,
  Pixel_Y: Single): WideChar;
var
  X, Y, W: Single;
begin
  X := 0; Y := 0;
  while Text^ <> WideNull do
  begin
    if (Text^ = WideCR) and (PWideChar(Integer(Text)+SizeOf(WideChar))^ = WideLF) then
    begin
      X := 0;
      Y := m_nFontSize + m_nKerningWidth;
      Inc(Text);
      if Text^ = WideNull then
        Break;
    end; 
    W := GetWidthFromCharacter(Text^);
    if (Pixel_X > X) and (Pixel_X <= X + W) and
      (Pixel_Y > Y) and (Pixel_Y <= Y + m_nFontSize) then
    begin
      Result := Text^;
      Exit;
    end;
    X := X + W + m_nKerningWidth;
    Inc(Text);
  end;
  Result := WideNull;
end;

function TGfxFont.GetColor(i: Integer): Cardinal;
begin
  Result := m_pSprite.GetColor(i);
end;

function TGfxFont.GetFontSize: Single;
begin
  Result := m_nFontSize;
end;

function TGfxFont.GetGlyphByCharacter(C: WideChar): Cardinal;
var
  Idx: Cardinal;
begin
  Idx := Cardinal(C);
  if m_Glyphs[Idx].t = nil then
    CacheCharacter(Idx, C);
  Result := Idx;
end;

function TGfxFont.GetKerningHeight: Single;
begin
  Result := m_nKerningHeight;
end;

function TGfxFont.GetKerningWidth: Single;
begin
  Result := m_nKerningWidth;
end;

function TGfxFont.GetTextSize(Text: PWideChar): TSize;
var
  Dim: TSize;
  nRowWidth: Single;
begin
  nRowWidth := 0;
  Dim.cx := 0;
  Dim.cy := Round(m_nFontSize);
  while Text^ <> WideNull do
  begin
    if (Text^ = WideCR) and (PWideChar(Integer(Text)+SizeOf(WideChar))^ = WideLF) then
    begin
      Dim.cy := Round(m_nFontSize + m_nKerningHeight);
      if Dim.cx < nRowWidth then
        Dim.cx := Round(nRowWidth);
      nRowWidth := 0;
      Inc(Text, 2);
    end
    else
    begin
      nRowWidth := nRowWidth + GetWidthFromCharacter(Text^) + m_nKerningWidth;
      Inc(Text);
    end;
  end;
  if Dim.cx < Round(nRowWidth) then
    Dim.cx := Round(nRowWidth);
  Result := Dim;
end;

function TGfxFont.GetWidthFromCharacter(C: WideChar;
  Original: Boolean): Single;
var
  Idx: Cardinal;
begin
  Idx := GetGlyphByCharacter(C);
  if Original and (Idx > 0) and (Idx < Font_Count) then
  begin
    Result := m_Glyphs[Idx].c;
    Exit;
  end;
  if Idx >= $2000 then
    Result := m_nFontSize
  else
    Result := m_nFontSize/2;
end;

procedure TGfxFont.Print(X, Y: Single; Text: PWideChar);
var
  OffsetX, OffsetY: Single;
  Idx: Cardinal;
begin
  OffsetX := X; OffsetY := Y;
  while Text^ <> WideNull do
  begin
    if (Text^ = WideCR) and (PWideChar(Integer(Text)+SizeOf(WideChar))^ = WideLF) then
    begin
      OffsetX := X;
      OffsetY := OffsetY + m_nFontSize + m_nKerningHeight;
      Inc(Text, 2);
    end
    else
    begin
      Idx := GetGlyphByCharacter(Text^);
      if Idx > 0 then
      begin
        m_pSprite.SetTexture(m_Glyphs[Idx].t);
        m_pSprite.SetTextureRect(0, 0, m_Glyphs[Idx].w, m_Glyphs[Idx].h);
        m_pSprite.Render(OffsetX - m_Glyphs[Idx].x, OffsetY - m_Glyphs[Idx].y);
        OffsetX := OffsetX + GetWidthFromCharacter(Text^) + m_nKerningWidth;
      end
      else
        OffsetX := OffsetX + GetWidthFromCharacter(Text^) + m_nKerningWidth;

      Inc(Text);
    end;
  end;
end;

procedure TGfxFont.SetColor(Color: Cardinal; i: Integer);
begin
  m_pSprite.SetColor(Color, i);
end;

procedure TGfxFont.SetKerningHeight(Kerning: Single);
begin
  m_nKerningHeight := Kerning;
end;

procedure TGfxFont.SetKerningWidth(Kerning: Single);
begin
  m_nKerningWidth := Kerning;
end;

end.

========================================================================
#ifndef GDIFONT_H 
#define GDIFONT_H 
 
#include "../HGE16/include/hgesprite.h" 
 
class GfxFont 
{ 
public: 
	GfxFont(const char* lpsFontName, int nFaceSize, BOOL bBold = FALSE, BOOL bItalic = FALSE, BOOL bAntialias = TRUE); 
	~GfxFont(void); 
 
public: 
	// 渲染文本 
	virtual void	Print( float x, float y, const char *format, ... ); 
	virtual void	Render(float x, float y, const wchar_t* text ); 
 
	// 设置与获取颜色 
	virtual void	SetColor( DWORD dwColor, int i = -1 ); 
	virtual DWORD	GetColor( int i = 0 ); 
 
	// 获取文本宽高 
	virtual SIZE	GetTextSize( const wchar_t* text ); 
 
	// 根据坐标获取字符 
	virtual wchar_t	GetCharacterFromPos( const wchar_t* text, float pixel_x, float pixel_y ); 
 
	// 设置字间距 
	virtual void	SetKerningWidth( float kerning ); 
	virtual void	SetKerningHeight( float kerning ); 
 
	// 获取字间距 
	virtual float	GetKerningWidth(); 
	virtual float	GetKerningHeight(); 
 
	// 字体大小 
	virtual float	GetFontSize(); 
 
private: 
	// 根据字符获取轮廓 
	unsigned int	GetGlyphByCharacter( wchar_t c ); 
	inline float	GetWidthFromCharacter( wchar_t c, bool original = false ); 
	inline void		CacheCharacter(unsigned int idx, wchar_t c); 
 
	typedef struct tagEngineFontGlyph 
	{ 
		HTEXTURE	t; 
		float		w; 
		float		h; 
		float		x; 
		float		y; 
		float		c; 
	}TENGINEFONTGLYPH; 
 
	static const unsigned int font_count = 0xFFFF;// = sizeof(wchar_t); 
	TENGINEFONTGLYPH	m_Glyphs[font_count]; 
	UINT				m_nAntialias;//反锯齿 
	LONG				m_nAscent;//基线 
	DWORD				m_dwFontColor; 
	float				m_nFontSize; 
	float				m_nKerningWidth; 
	float				m_nKerningHeight; 
 
	HGE*				m_pHGE; 
	hgeSprite*			m_pSprite; 
 
	// GDI设备 
	HDC					m_hMemDC; 
	HFONT				m_hFont; 
}; 
#endif//GDIFONT_H 


====================================================================
#include "GfxFont.h"    
#include <ATLBASE.H>    
#include <STDIO.H>    
   
   
__inline float _floor(float f)   
{   
    static int _n;   
    _asm fld f   
    _asm fistp _n   
    return (float)_n;   
}   
   
// 65级灰度表    
const unsigned char g_byAlphaLevel[65] =    
{   
      0,  4,  8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48,   
     52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96,100,   
    104,108,112,116,120,124,128,132,136,140,144,148,152,   
    156,160,164,168,172,176,180,184,188,192,196,200,204,   
    208,212,216,220,224,228,232,236,240,244,248,252,255   
};   
   
GfxFont::GfxFont(const char* lpsFontName, int nFaceSize, BOOL bBold, BOOL bItalic, BOOL bAntialias)   
{   
    m_pHGE = hgeCreate(HGE_VERSION);   
   
    // 创建GDI相关设备    
    HDC hDC = GetDC(m_pHGE->System_GetState(HGE_HWND));   
    m_hMemDC = CreateCompatibleDC(hDC);   
    if (NULL == m_hMemDC) return;   
    ReleaseDC(m_pHGE->System_GetState(HGE_HWND),hDC);   
   
    ::SetMapMode(m_hMemDC, MM_TEXT);   
    ::SetTextColor(m_hMemDC,RGB(255,255,255));   
    ::SetBkColor(m_hMemDC,RGB(0,0,0));   
   
    m_hFont = CreateFont(   
        -nFaceSize,   
        0,   
        0,   
        0,   
        (bBold) ? FW_BOLD : FW_NORMAL,   
        bItalic,   
        FALSE,   
        FALSE,   
        DEFAULT_CHARSET,   
        OUT_DEFAULT_PRECIS,   
        CLIP_DEFAULT_PRECIS,   
        DEFAULT_QUALITY,   
        FF_DONTCARE | DEFAULT_PITCH,   
        lpsFontName);   
    if (NULL == (m_hFont)) return;   
    SelectObject(m_hMemDC, m_hFont);   
   
    memset(m_Glyphs,0,sizeof(TENGINEFONTGLYPH)*font_count);   
   
    m_nAntialias    = bAntialias ? GGO_GRAY8_BITMAP : GGO_BITMAP;   
   
    TEXTMETRIC tm;   
    ::GetTextMetrics(m_hMemDC,&tm);   
    m_nAscent       = tm.tmAscent;   
   
    m_nFontSize     = static_cast<FLOAT>(nFaceSize);   
    m_nKerningWidth = 0;   
    m_nKerningHeight= 0;   
   
    m_pSprite = new hgeSprite(0, 0, 0, 0, 0);   
    m_pSprite->SetColor(ARGB(255, 255, 255, 255));   
}   
   
GfxFont::~GfxFont(void)   
{   
    for (int nIdx = 0; nIdx < font_count; ++nIdx)   
    { if (m_Glyphs[nIdx].t) m_pHGE->Texture_Free(m_Glyphs[nIdx].t); }   
   
    if ((m_hFont)) DeleteObject(m_hFont);   
    if ((m_hMemDC)) DeleteDC(m_hMemDC);   
   
    if(m_pSprite) delete m_pSprite;   
    if(m_pHGE) m_pHGE->Release();   
}   
   
// 渲染文本    
void GfxFont::Print( float x, float y, const char *format, ... )   
{   
    char sBuffer[10240] = {0};   
    char *lpsArg=(char*)&format+sizeof(format);   
    vsprintf(sBuffer, format, lpsArg);   
   
    Render(x,y,CA2W(sBuffer));   
}   
   
void GfxFont::Render(float x, float y, const wchar_t* text )   
{   
    float offsetX = x;   
    float offsetY = y;   
   
    while(*text)   
    {   
        if (*text == L'\n' || *text == L'\r')   
        {   
            offsetX = x;   
            offsetY += (m_nFontSize + m_nKerningHeight);   
        }   
        else   
        {   
            unsigned int idx = GetGlyphByCharacter(*text);   
            if (idx > 0)   
            {   
                m_pSprite->SetTexture(m_Glyphs[idx].t);   
                m_pSprite->SetTextureRect(0, 0, m_Glyphs[idx].w, m_Glyphs[idx].h);   
                m_pSprite->Render(offsetX - m_Glyphs[idx].x, offsetY - m_Glyphs[idx].y);   
                offsetX += (GetWidthFromCharacter(*text) + m_nKerningWidth);   
            }   
            else   
            {   
                offsetX += (GetWidthFromCharacter(*text) + m_nKerningWidth);   
            }   
        }   
   
        ++text;   
    }   
}   
   
// 设置与获取颜色    
void GfxFont::SetColor( DWORD dwColor, int i )   
{   
    m_pSprite->SetColor(dwColor,i);   
}   
   
DWORD GfxFont::GetColor(int i)   
{   
    return m_pSprite->GetColor(i);   
}   
   
// 获取文本宽高    
SIZE GfxFont::GetTextSize( const wchar_t* text )   
{   
    SIZE dim = {0, static_cast<LONG>(m_nFontSize)};   
    float nRowWidth = 0;   
   
    while(*text)   
    {   
        if (*text == L'\n' || *text == L'\r')   
        {   
            dim.cy += static_cast<LONG>(m_nFontSize + m_nKerningHeight);   
            if (dim.cx < static_cast<LONG>(nRowWidth))   
                dim.cx = static_cast<LONG>(nRowWidth);   
            nRowWidth = 0;   
        }   
        else   
            nRowWidth += (GetWidthFromCharacter(*text) + m_nKerningWidth);   
        ++text;   
    }   
   
    if (dim.cx < static_cast<LONG>(nRowWidth))   
        dim.cx = static_cast<LONG>(nRowWidth);   
   
    return dim;   
}   
   
// 根据坐标获取字符    
wchar_t GfxFont::GetCharacterFromPos( const wchar_t* text, float pixel_x, float pixel_y )   
{   
    float x = 0;   
    float y = 0;   
   
    while (*text)   
    {   
        if (*text == L'\n' || *text == L'\r')   
        {   
            x = 0;   
            y += (m_nFontSize+m_nKerningHeight);   
            text++;   
   
            if (!(*text))   
                break;   
        }   
   
        float w = GetWidthFromCharacter(*text);   
        if (pixel_x > x && pixel_x <= x + w &&   
            pixel_y > y && pixel_y <= y + m_nFontSize)   
            return *text;   
   
        x += (w+m_nKerningWidth);   
   
        text++;   
    }   
   
    return L'\0';   
}   
   
// 设置字间距    
void GfxFont::SetKerningWidth( float kerning )   
{   
    m_nKerningWidth = kerning;   
}   
void GfxFont::SetKerningHeight( float kerning )   
{   
    m_nKerningHeight = kerning;   
}   
   
// 获取字间距    
float GfxFont::GetKerningWidth()   
{   
    return m_nKerningWidth;   
}   
float GfxFont::GetKerningHeight()   
{   
    return m_nKerningHeight;   
}      
   
// 字体大小    
float GfxFont::GetFontSize()   
{   
    return m_nFontSize;   
}   
   
// 根据字符获取轮廓    
unsigned int GfxFont::GetGlyphByCharacter( wchar_t c )   
{   
    unsigned int idx = (unsigned int)c;   
    if (NULL == (m_Glyphs[idx].t)) CacheCharacter(idx,c);   
    return idx;   
}   
inline float GfxFont::GetWidthFromCharacter( wchar_t c, bool original )   
{   
    unsigned int idx = GetGlyphByCharacter(c);   
    if (original && idx > 0 && idx < font_count) return m_Glyphs[idx].c;   
    return  (idx >= 0x2000) ? m_nFontSize : _floor(m_nFontSize / 2);   
}   
inline void GfxFont::CacheCharacter(unsigned int idx, wchar_t c)   
{   
    if (idx < font_count && NULL == m_Glyphs[idx].t)   
    {   
        UINT nChar = (UINT)c;   
   
        MAT2 mat2 = {{0,1},{0,0},{0,0},{0,1}};   
        GLYPHMETRICS gm;   
        DWORD nLen = ::GetGlyphOutlineW(m_hMemDC,nChar,m_nAntialias,&gm,0,NULL,&mat2);   
   
        HTEXTURE hTex = m_pHGE->Texture_Create(gm.gmBlackBoxX,gm.gmBlackBoxY);   
        if (NULL == hTex) return;   
   
        if((signed)nLen > 0)   
        {   
            LPBYTE lpBuf = new BYTE[nLen];   
   
            if (nLen == ::GetGlyphOutlineW(m_hMemDC,nChar,m_nAntialias,&gm,nLen,lpBuf,&mat2))   
            {   
                BYTE*   lpSrc = lpBuf;   
                DWORD*  lpDst = m_pHGE->Texture_Lock(hTex,FALSE);   
   
                if (GGO_BITMAP == m_nAntialias)   
                {   
                    LONG nSrcPitch = (gm.gmBlackBoxX / 32 + (gm.gmBlackBoxX % 32 == 0 ? 0 : 1)) * 4;   
                    LONG nDstPitch = m_pHGE->Texture_GetWidth(hTex);   
   
                    for (UINT y = 0; y < gm.gmBlackBoxY; ++y)   
                    {   
                        for (UINT x = 0; x < gm.gmBlackBoxX; ++x)   
                        {   
                            for(UINT k = 0; k < 8; ++k)      
                            {   
                                UINT i = 8 * x + k;   
                                if (i >= gm.gmBlackBoxX)   
                                {   
                                    x+=7;   
                                    break;   
                                }   
                                lpDst[i] = ((lpSrc[x] >> (7 - k)) & 1) ? 0xFFFFFFFF : 0x0;   
                            }   
                        }   
   
                        lpSrc += nSrcPitch;   
                        lpDst += nDstPitch;   
                    }   
                }   
                else   
                {   
                    LONG nSrcPitch = (gm.gmBlackBoxX / 4 + (gm.gmBlackBoxX % 4 == 0 ? 0 : 1)) * 4;   
                    LONG nDstPitch = m_pHGE->Texture_GetWidth(hTex);   
   
                    for (UINT y = 0; y < gm.gmBlackBoxY; ++y)   
                    {   
                        for (UINT x = 0; x < gm.gmBlackBoxX; ++x)   
                        {   
                            lpDst[x] = ARGB(g_byAlphaLevel[lpSrc[x]],0xFF,0xFF,0xFF);   
                        }   
   
                        lpSrc += nSrcPitch;   
                        lpDst += nDstPitch;   
                    }   
                }   
   
                m_pHGE->Texture_Unlock(hTex);   
            }   
   
            delete lpBuf;   
        }   
        else   
        {   
            // 非正常显示字符    
        }   
   
        m_Glyphs[idx].t = hTex;   
        m_Glyphs[idx].w = static_cast<FLOAT>(gm.gmBlackBoxX);   
        m_Glyphs[idx].h = static_cast<FLOAT>(gm.gmBlackBoxY);   
        m_Glyphs[idx].x = static_cast<FLOAT>(-gm.gmptGlyphOrigin.x);   
        m_Glyphs[idx].y = static_cast<FLOAT>(-m_nAscent + gm.gmptGlyphOrigin.y);   
        m_Glyphs[idx].c = static_cast<FLOAT>(gm.gmCellIncX);   
    }   
}   
