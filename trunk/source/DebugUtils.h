/*******************************************************************************
  Filename:		KmDebug.h
  Author:		Tramper
  Email:		lingoooooooooo@gmail.com
  Date:			2009/12/15

  Brief:    	这是KamaLib代码库的一部分，由Tramper创建并维护，版权没有，
				请自由使用！
 -------------------------------------------------------------------------------
  Description: 
	调试辅助函数
	1. 断言，跟踪和日志; 
	2. 高性能计数器
	3. 动态对象内存测漏

*******************************************************************************/
#ifndef __LIN_KMDEBUG_H__
#define __LIN_KMDEBUG_H__
#include <crtdbg.h>
#include <stdio.h>

namespace lin
{

/*
	断言: KASSERT
*/
#ifdef _DEBUG
	#define KASSERT(exp)\
		do {\
			if (!(exp) && (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #exp))) \
				_CrtDbgBreak(); \
		} while(0)
#else
	#define KASSERT(exp) ((void)0)
#endif

/*
	跟踪: KTRACE 每次调用都将自动换行，最多只支持512个字符
*/
#ifdef _DEBUG
	inline void __cdecl _KTrace(LPCWSTR szFormat, ...)
	{
		va_list args;
		va_start(args, szFormat);
		WCHAR szBuf[512] = {0};
		_vsnwprintf(szBuf, 512, szFormat, args);
		wcscat(szBuf, L"\r\n");
		OutputDebugStringW(szBuf);
		va_end(args);
	}
	#define KTRACE _KTrace
#else
	#define KTRACE __noop
#endif

/*
	日志记录: 
	KLOG: 自动换行
	KLOG2: 不自动换行
	最大字符数为512
	可调用SETLOGPATH设置日志文件的路径
*/
#if defined(USE_LOG) || defined(_DEBUG)
	_declspec(selectany) HANDLE _gLogFile = INVALID_HANDLE_VALUE;

	/*
		设置日志文本路径，如果path为NULL，日志输出到应用程序目录下，名字为: appname.log
	*/
	inline void _SetLogPath(LPCWSTR path)
	{
		WCHAR szPath[MAX_PATH] = {0};
		if (NULL == path)
		{
			::GetModuleFileNameW(NULL, szPath, MAX_PATH);
			size_t i = wcslen(szPath);
			while (--i >= 0)
			{
				if (szPath[i] == '.')
				{
					wcscat(szPath, L"log");
					break;
				}
				else
					szPath[i] = 0;
			}
		}
		else
		{
			wcscpy(szPath, path);
		}

		// 创建日志文件
		_gLogFile = ::CreateFileW(
			szPath, 
			GENERIC_READ | GENERIC_WRITE, 
			FILE_SHARE_READ, 
			NULL, 
			CREATE_ALWAYS, 
			FILE_ATTRIBUTE_NORMAL, 
			NULL);

		if (INVALID_HANDLE_VALUE != _gLogFile)
		{
			// 写UNICODE文本头
			WCHAR UNICODEBOM = 0xFEFF;
			DWORD writeSize;
			::WriteFile(_gLogFile, &UNICODEBOM, 2, &writeSize, NULL);	
		}
	}

	inline void __cdecl _KLogEx(BOOL oneLine, LPCWSTR szFormat, va_list args)
	{
		
		WCHAR szBuf[512] = {0};
		_vsnwprintf(szBuf, 512, szFormat, args);
		if (oneLine)
			wcscat(szBuf, L"\r\n");

		DWORD writeSize;
		if (INVALID_HANDLE_VALUE == _gLogFile)
			_SetLogPath(NULL);
		if (INVALID_HANDLE_VALUE != _gLogFile)
			WriteFile(_gLogFile, szBuf, (DWORD)wcslen(szBuf) * sizeof(WCHAR), &writeSize, NULL);
	}
	inline void _cdecl _KLog(LPCWSTR szFormat, ...)
	{
		va_list args;
		va_start(args, szFormat);
		_KLogEx(TRUE, szFormat, args);
		va_end(args);	
	}
	inline void _cdecl _KLog2(LPCWSTR szFormat, ...)
	{
		va_list args;
		va_start(args, szFormat);
		_KLogEx(FALSE, szFormat, args);
		va_end(args);	
	}

	#define KLOG		_KLog
	#define KLOG2		_KLog2
	#define SETLOGPATH	_SetLogPath
#else
	#define KLOG		__noop
	#define KLOG2		__noop
	#define SETLOGPATH	__noop
#endif

//------------------------------------------------------------------------------
/*
	高性能计数器，使用方法
	BeginTimeCounter;
	// you code
	double secon = EndTimeCounter;
*/
_declspec(selectany) LARGE_INTEGER _gFrequency;
_declspec(selectany) LARGE_INTEGER _gCounter;

inline void _InitCounter()
{
	if (_gFrequency.QuadPart == 0)
		QueryPerformanceFrequency(&_gFrequency);
}

inline LARGE_INTEGER _QueryCounter()
{
	_InitCounter();
	LARGE_INTEGER count;
	QueryPerformanceCounter(&count);
	return count;
}

/*
	开始计数
*/
inline void BeginTimeCounter()
{
	_gCounter = _QueryCounter();
}

/*
	结束计数，返回的结果以秒为单位
*/
inline double EndTimeCounter()
{
	LARGE_INTEGER counter = _QueryCounter();
	return double(counter.QuadPart - _gCounter.QuadPart) / double(_gFrequency.QuadPart);
}

//------------------------------------------------------------------------------
/*
	动态类实例测漏，在类声明里增加宏：DECLARE_OBJCHECKER(ClassName)
	ClassName是类的名字，比如：
		class MyClass
		{
		private:
			DECLARE_OBJCHECKER(MyClass)
		};
	程序结束时，如果存在该类的实例未释放，则会在Output窗口里打印出来
*/

/*
	类实例计数器，内部使用
*/
class _KObjectCounter
{
public:
	_KObjectCounter(const char* szClass, const char* szFile, int nLine)
		: mRef(0), mClass(szClass), mFile(szFile), mLine(nLine) 
	{
	}

	~_KObjectCounter()
	{ 
		if (mRef > 0)
			KTRACE(L"object leak:\n\tclass: %s\n\tinstance count: %d\n\tfile: %s\n\tline: %d\n", 
			mClass, mRef, mFile, mLine);
	}

	void operator++()	
	{ 
		++mRef; 
	}

	void operator--()	
	{ 
		--mRef; 
	}
public:
	unsigned	mRef;
	const char* mClass;
	const char* mFile;
	int			mLine;
};

#ifndef _DEBUG
#	define DECLARE_CLASSCHECKER(Class)
#else
#	define DECLARE_CLASSCHECKER(Class)									\
class KObjectChecker													\
{																		\
public:																	\
	KObjectChecker() { ++Counter(); }									\
	~KObjectChecker() { --Counter(); }									\
private:																\
	CCounteChecker& Counter()											\
	{ static _KObjectCounter c(#Class, __FILE__, __LINE__);				\
		return c; }														\
} mChecker;												
#endif



}
#endif // __LIN_KMDEBUG_H__